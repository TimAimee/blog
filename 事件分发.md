一直对Android事件分发的问题，搞的云里雾里的，正所谓念念不忘，必有回响，今日得空，整理一个文章

demo程序很简单，AMainActivity设置了一个简单的layout,BViewGroupxxx继承自 ViewGroup,CView继承自 View.

对于事件分发，各个类都包含了几个重要的方法。

Activity中包含了两个重要的方法

	dispatchTouchEvent
	onTouchEvent

ViewGroup 中包含了三个重要的方法

	dispatchTouchEvent
	onInterceptTouchEvent
	onTouchEvent

View 中包含了两个重要的方法

	dispatchTouchEvent
	onTouchEvent

对于类名以及log出现的多个'x',主要是为了打印日志的长度一致，方便分析
	
	AMainActivity
	BViewGroupxxx
	CViewxxxxxxxx

	dispatchTouchEventxxx
	onInterceptTouchEvent
	onTouchEventxxxxxxxxx

# Layout
    <?xml version="1.0" encoding="utf-8"?>
	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
	    xmlns:app="http://schemas.android.com/apk/res-auto"
	    android:layout_width="match_parent"
	    android:layout_height="match_parent"
	    android:orientation="vertical">
	
	    <com.vphealthy.viewgroupdemo.BViewGroupxxx
	        android:layout_width="200dp"
	        android:layout_height="200dp"
	        android:background="@color/colorPrimary">
	
	        <com.vphealthy.viewgroupdemo.CViewxxxxxxxx
	            android:layout_width="100dp"
	            android:layout_height="100dp"
	            android:background="@color/colorAccent" />
	        
	    </com.vphealthy.viewgroupdemo.BViewGroupxxx>
	
	</LinearLayout>
 
# AMainActivity

	@Override
    public boolean dispatchTouchEvent(MotionEvent ev) {
        switch (ev.getAction()) {
            case MotionEvent.ACTION_DOWN:
                Log.i(TAG, "dispatchTouchEventxxx ACTION_DOWN");
                break;
            case MotionEvent.ACTION_MOVE:
                Log.i(TAG, "dispatchTouchEventxxx ACTION_MOVE");
                break;
            case MotionEvent.ACTION_UP:
                Log.i(TAG, "dispatchTouchEventxxx ACTION_UP");
                break;
        }
        return super.dispatchTouchEvent(ev);
    }

 	@Override
    public boolean onTouchEvent(MotionEvent ev) {
        switch (ev.getAction()) {
            case MotionEvent.ACTION_DOWN:
                Log.i(TAG, "onTouchEventxxxxxxxxx ACTION_DOWN");
                break;
            case MotionEvent.ACTION_MOVE:
                Log.i(TAG, "onTouchEventxxxxxxxxx ACTION_MOVE");
                break;
            case MotionEvent.ACTION_UP:
                Log.i(TAG, "onTouchEventxxxxxxxxx ACTION_UP");
                break;
        }
        return super.onTouchEvent(ev);
    }

# BViewGroupxxx

	@Override
    public boolean dispatchTouchEvent(MotionEvent ev) {
        switch (ev.getAction()) {
            case MotionEvent.ACTION_DOWN:
                Log.i(TAG, "dispatchTouchEventxxx ACTION_DOWN");
                break;
            case MotionEvent.ACTION_MOVE:
                Log.i(TAG, "dispatchTouchEventxxx ACTION_MOVE");
                break;
            case MotionEvent.ACTION_UP:
                Log.i(TAG, "dispatchTouchEventxxx ACTION_UP");
                break;
        }
        return super.dispatchTouchEvent(ev);
    }

	@Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        switch (ev.getAction()) {
            case MotionEvent.ACTION_DOWN:
                Log.i(TAG, "onInterceptTouchEvent ACTION_DOWN");
                break;
            case MotionEvent.ACTION_MOVE:
                Log.i(TAG, "onInterceptTouchEvent ACTION_MOVE");
                break;
            case MotionEvent.ACTION_UP:
                Log.i(TAG, "onInterceptTouchEvent ACTION_UP");
                break;
        }
        return super.onInterceptTouchEvent(ev);
    }

    @Override
    public boolean onTouchEvent(MotionEvent ev) {
        switch (ev.getAction()) {
            case MotionEvent.ACTION_DOWN:
                Log.i(TAG, "onTouchEventxxxxxxxxx ACTION_DOWN");
                break;
            case MotionEvent.ACTION_MOVE:
                Log.i(TAG, "onTouchEventxxxxxxxxx ACTION_MOVE");
                break;
            case MotionEvent.ACTION_UP:
                Log.i(TAG, "onTouchEventxxxxxxxxx ACTION_UP");
                break;
        }
        return super.onTouchEvent(ev);
    }

# CViewxxxxxxxx

		@Override
	    public boolean dispatchTouchEvent(MotionEvent ev) {
	        switch (ev.getAction()) {
	            case MotionEvent.ACTION_DOWN:
	                Log.i(TAG, "dispatchTouchEventxxx ACTION_DOWN");
	                break;
	            case MotionEvent.ACTION_MOVE:
	                Log.i(TAG, "dispatchTouchEventxxx ACTION_MOVE");
	                break;
	            case MotionEvent.ACTION_UP:
	                Log.i(TAG, "dispatchTouchEventxxx ACTION_UP");
	                break;
	        }
	        return super.dispatchTouchEvent(ev);
	    }

		@Override
	    public boolean onTouchEvent(MotionEvent event) {
	        switch (event.getAction()) {
	            case MotionEvent.ACTION_DOWN:
	                Log.i(TAG, "onTouchEventxxxxxxxxx ACTION_DOWN");
	                break;
	            case MotionEvent.ACTION_MOVE:
	                Log.i(TAG, "onTouchEventxxxxxxxxx ACTION_MOVE");
	                break;
	            case MotionEvent.ACTION_UP:
	                Log.i(TAG, "onTouchEventxxxxxxxxx ACTION_UP");
	                break;
	        }
	        return super.onTouchEvent(event);
	    }




以下所有的操作都只是一种，按下->移动->抬起



# 情况A（只针对View.onTouchEvent【super,false,true】）

## 情况A.1
可以看到当我们所有的事件回复都是super时，

	//Down事件	 
	15:42:41.720 25128-25128/com.vphealthy.viewgroupdemo I/AMainActivity: dispatchTouchEventxxx ACTION_DOWN
	15:42:41.721 25128-25128/com.vphealthy.viewgroupdemo I/BViewGroupxxx: dispatchTouchEventxxx ACTION_DOWN
	15:42:41.721 25128-25128/com.vphealthy.viewgroupdemo I/BViewGroupxxx: onInterceptTouchEvent ACTION_DOWN
	15:42:41.721 25128-25128/com.vphealthy.viewgroupdemo I/CViewxxxxxxxx: dispatchTouchEventxxx ACTION_DOWN
	15:42:41.721 25128-25128/com.vphealthy.viewgroupdemo I/CViewxxxxxxxx: onTouchEventxxxxxxxxx ACTION_DOWN
	15:42:41.721 25128-25128/com.vphealthy.viewgroupdemo I/BViewGroupxxx: onTouchEventxxxxxxxxx ACTION_DOWN
	15:42:41.721 25128-25128/com.vphealthy.viewgroupdemo I/AMainActivity: onTouchEventxxxxxxxxx ACTION_DOWN
	//MOVE事件
	15:50:09.583 25376-25376/com.vphealthy.viewgroupdemo I/AMainActivity: dispatchTouchEventxxx ACTION_MOVE
	15:50:08.566 25376-25376/com.vphealthy.viewgroupdemo I/AMainActivity: onTouchEventxxxxxxxxx ACTION_MOVE
	//UP事件
	15:42:41.763 25128-25128/com.vphealthy.viewgroupdemo I/AMainActivity: dispatchTouchEventxxx ACTION_UP
	15:42:41.763 25128-25128/com.vphealthy.viewgroupdemo I/AMainActivity: onTouchEventxxxxxxxxx ACTION_UP

Down事件的流程是 Activity->ViewGroup->View->ViewGroup->Activity,

日志传递流程是 AMainActivity.dispatchTouchEventxxx

日志传递流程是 BViewGroupxxx.dispatchTouchEventxxx->BViewGroupxxx.onInterceptTouchEvent

日志传递流程是 CViewxxxxxxxx.dispatchTouchEventxxx->CViewxxxxxxxx.onTouchEventxxxxxxxxx

日志传递流程是 BViewGroupxxx.onTouchEventxxxxxxxxx

日志传递流程是 AMainActivity.onTouchEventxxxxxxxxx

UP&move事件则只在MainActivity中处理，为什么不传递给ViewGroup->View？

当Down传递到View.onTouchEvent，不View被消费时，还会回传到ViewGroup.onTouchEvent,MainActivity.onTouchEvent，

并且后续的MOVE,UP事件也不会再传递给ViewGroup和View了。



## 情况A.2

现在我们将View中的onTouchEvent方法返回false,其他均为super，与(A.1)的现象一致。

## 情况A.3

现在我们将View中的onTouchEvent方法返回true,其他均为super。

	//Down事件	
	15:52:52.666 25944-25944/com.vphealthy.viewgroupdemo I/AMainActivity: dispatchTouchEventxxx ACTION_DOWN
	15:52:52.667 25944-25944/com.vphealthy.viewgroupdemo I/BViewGroupxxx: dispatchTouchEventxxx ACTION_DOWN
	15:52:52.667 25944-25944/com.vphealthy.viewgroupdemo I/BViewGroupxxx: onInterceptTouchEvent ACTION_DOWN
	15:52:52.667 25944-25944/com.vphealthy.viewgroupdemo I/CViewxxxxxxxx: dispatchTouchEventxxx ACTION_DOWN
	15:52:52.667 25944-25944/com.vphealthy.viewgroupdemo I/CViewxxxxxxxx: onTouchEventxxxxxxxxx ACTION_DOWN
	//MOVE事件	
	15:52:52.685 25944-25944/com.vphealthy.viewgroupdemo I/AMainActivity: dispatchTouchEventxxx ACTION_MOVE
	15:52:52.685 25944-25944/com.vphealthy.viewgroupdemo I/BViewGroupxxx: dispatchTouchEventxxx ACTION_MOVE
	15:52:52.685 25944-25944/com.vphealthy.viewgroupdemo I/BViewGroupxxx: onInterceptTouchEvent ACTION_MOVE
	15:52:52.685 25944-25944/com.vphealthy.viewgroupdemo I/CViewxxxxxxxx: dispatchTouchEventxxx ACTION_MOVE
	15:52:52.685 25944-25944/com.vphealthy.viewgroupdemo I/CViewxxxxxxxx: onTouchEventxxxxxxxxx ACTION_MOVE
	//UP事件	
	15:52:53.226 25944-25944/com.vphealthy.viewgroupdemo I/AMainActivity: dispatchTouchEventxxx ACTION_UP
	15:52:53.226 25944-25944/com.vphealthy.viewgroupdemo I/BViewGroupxxx: dispatchTouchEventxxx ACTION_UP
	15:52:53.226 25944-25944/com.vphealthy.viewgroupdemo I/BViewGroupxxx: onInterceptTouchEvent ACTION_UP
	15:52:53.226 25944-25944/com.vphealthy.viewgroupdemo I/CViewxxxxxxxx: dispatchTouchEventxxx ACTION_UP
	15:52:53.226 25944-25944/com.vphealthy.viewgroupdemo I/CViewxxxxxxxx: onTouchEventxxxxxxxxx ACTION_UP

Down事件的流程是 MainActivity->ViewGroup->View

日志传递流程是 AMainActivity.dispatchTouchEventxxx

日志传递流程是 BViewGroupxxx.dispatchTouchEventxxx->BViewGroupxxx.onInterceptTouchEvent

日志传递流程是 CViewxxxxxxxx.dispatchTouchEventxxx->CViewxxxxxxxx.onTouchEventxxxxxxxxx

UP&move事件也同于Down事件

这里与(A.1)相比就发现了2个区别

1.View.onTouchEvent返回ture以后，ViewGroup.onTouchEvent以及Activity.onTouchEvent不会再调用了

2.View.onTouchEvent返回ture以后，down和move方法不只在Activity执行了，也会分发给ViewGroup和View

## 情况A.4

现在我们将ViewGroup中的onTouchEvent方法返回true,其他均super。
	
	//Down事件	
	17:51:40.790 2159-2159/com.vphealthy.viewgroupdemo I/AMainActivity: dispatchTouchEventxxx ACTION_DOWN
	17:51:40.791 2159-2159/com.vphealthy.viewgroupdemo I/BViewGroupxxx: dispatchTouchEventxxx ACTION_DOWN
	17:51:40.791 2159-2159/com.vphealthy.viewgroupdemo I/BViewGroupxxx: onInterceptTouchEvent ACTION_DOWN
	17:51:40.791 2159-2159/com.vphealthy.viewgroupdemo I/CViewxxxxxxxx: dispatchTouchEventxxx ACTION_DOWN
	17:51:40.791 2159-2159/com.vphealthy.viewgroupdemo I/CViewxxxxxxxx: onTouchEventxxxxxxxxx ACTION_DOWN
	17:51:40.791 2159-2159/com.vphealthy.viewgroupdemo I/BViewGroupxxx: onTouchEventxxxxxxxxx ACTION_DOWN
	//MOVE事件	
	17:51:40.798 2159-2159/com.vphealthy.viewgroupdemo I/AMainActivity: dispatchTouchEventxxx ACTION_MOVE
	17:51:40.798 2159-2159/com.vphealthy.viewgroupdemo I/BViewGroupxxx: dispatchTouchEventxxx ACTION_MOVE
	17:51:40.798 2159-2159/com.vphealthy.viewgroupdemo I/BViewGroupxxx: onTouchEventxxxxxxxxx ACTION_MOVE
	//up事件
	17:51:41.007 2159-2159/com.vphealthy.viewgroupdemo I/AMainActivity: dispatchTouchEventxxx ACTION_UP
	17:51:41.007 2159-2159/com.vphealthy.viewgroupdemo I/BViewGroupxxx: dispatchTouchEventxxx ACTION_UP
	17:51:41.007 2159-2159/com.vphealthy.viewgroupdemo I/BViewGroupxxx: onTouchEventxxxxxxxxx ACTION_UP

Down事件的流程是 MainActivity->ViewGroup->View

日志传递流程是 AMainActivity.dispatchTouchEventxxx

日志传递流程是 BViewGroupxxx.dispatchTouchEventxxx->BViewGroupxxx.onInterceptTouchEvent

日志传递流程是 CViewxxxxxxxx.dispatchTouchEventxxx->CViewxxxxxxxx.onTouchEventxxxxxxxxx->BViewGroupxxx.onTouchEventxxxxxxxxx


UP&move事件则不同于Down事件

日志传递流程是 AMainActivity.dispatchTouchEventxxx

日志传递流程是 BViewGroupxxx.dispatchTouchEventxxx->BViewGroupxxx.onTouchEventxxxxxxxxx，

发现了么，onInterceptTouchEvent不调用了，直接就调用了onTouchEventxxxxxxxxx，

子类的onTouchEventxxxxxxxxx返回super，即不处理时，BViewGroupxxx的UP&move事件的onInterceptTouchEvent都不分发了?

# 这是为啥呢？


都是

# 情况A结论

当Activity，ViewGroup 返回均为super时且View的dispatchTouchEvent返回super时，

只有View的onTouchEvent返回ture;之后的move及up事件才会再传给view.

# 这是为啥呢？

当Activity，ViewGroup,View返回均为super时，只有ViewGroup的onTouch返回true, 
BViewGroupxxx后续的UP&move事件的onInterceptTouchEvent都不分发了?

# 这是为啥呢？



# 情况B（针对View.dispatchTouchEvent【true】和View.onTouchEvent【super,false,true】）

## 情况B.1

现在我们将View中的dispatchTouchEvent也返回true,onTouchEvent方法返回true,其他均不变。

	//Down事件		
	16:12:50.244 27405-27405/com.vphealthy.viewgroupdemo I/AMainActivity: dispatchTouchEventxxx ACTION_DOWN
	16:12:50.245 27405-27405/com.vphealthy.viewgroupdemo I/BViewGroupxxx: dispatchTouchEventxxx ACTION_DOWN
	16:12:50.245 27405-27405/com.vphealthy.viewgroupdemo I/BViewGroupxxx: onInterceptTouchEvent ACTION_DOWN
	16:12:50.245 27405-27405/com.vphealthy.viewgroupdemo I/CViewxxxxxxxx: dispatchTouchEventxxx ACTION_DOWN
	//MOVE事件	
	16:12:50.499 27405-27405/com.vphealthy.viewgroupdemo I/AMainActivity: dispatchTouchEventxxx ACTION_MOVE
	16:12:50.500 27405-27405/com.vphealthy.viewgroupdemo I/BViewGroupxxx: dispatchTouchEventxxx ACTION_MOVE
	16:12:50.500 27405-27405/com.vphealthy.viewgroupdemo I/BViewGroupxxx: onInterceptTouchEvent ACTION_MOVE
	16:12:50.500 27405-27405/com.vphealthy.viewgroupdemo I/CViewxxxxxxxx: dispatchTouchEventxxx ACTION_MOVE
	//UP事件	
	16:12:50.680 27405-27405/com.vphealthy.viewgroupdemo I/AMainActivity: dispatchTouchEventxxx ACTION_UP
	16:12:50.681 27405-27405/com.vphealthy.viewgroupdemo I/BViewGroupxxx: dispatchTouchEventxxx ACTION_UP
	16:12:50.681 27405-27405/com.vphealthy.viewgroupdemo I/BViewGroupxxx: onInterceptTouchEvent ACTION_UP
	16:12:50.681 27405-27405/com.vphealthy.viewgroupdemo I/CViewxxxxxxxx: dispatchTouchEventxxx ACTION_UP

Down事件的流程是 MainActivity->ViewGroup->View

日志传递流程是 AMainActivity.dispatchTouchEventxxx

日志传递流程是 BViewGroupxxx.dispatchTouchEventxxx->BViewGroupxxx.onInterceptTouchEvent

日志传递流程是 CViewxxxxxxxx.dispatchTouchEventxxx

UP&move事件也同于Down事件

这里与情况与(A.3)相比就发现了1个区别

1.当事件传递到View.dispatchTouchEvent返回ture时，View.onTouchEvent不会再被执行，

## 情况B.2

现在我们将View中的dispatchTouchEvent返回true,View.onTouchEvent方法返回true,其他均不变。与(B.1)的现象一致。

## 情况B.3

现在我们将View中的dispatchTouchEvent返回true,View.onTouchEvent方法返回super,其他均不变。与(B.1)的现象一致。

# 情况B结论

现在我们将View中的dispatchTouchEvent返回true时，表示事件被View.dispatchTouchEvent消费，

View.onTouchEvent无论返回什么都不会被调用。

原因可以在View.java的源码可以找到
	
	public boolean dispatchTouchEvent(MotionEvent event) {
        // If the event should be handled by accessibility focus first.
        if (event.isTargetAccessibilityFocus()) {
            // We don't have focus or no virtual descendant has it, do not handle the event.
            if (!isAccessibilityFocusedViewOrHost()) {
                return false;
            }
            // We have focus and got the event, then use normal event dispatch.
            event.setTargetAccessibilityFocus(false);
        }

        boolean result = false;
		....
        if (onFilterTouchEventForSecurity(event)) {
            if ((mViewFlags & ENABLED_MASK) == ENABLED && handleScrollBarDragging(event)) {
                result = true;
            }
            //noinspection SimplifiableIfStatement
            ListenerInfo li = mListenerInfo;
            if (li != null && li.mOnTouchListener != null
                    && (mViewFlags & ENABLED_MASK) == ENABLED
                    && li.mOnTouchListener.onTouch(this, event)) {
                result = true;
            }

            if (!result && onTouchEvent(event)) {  //看这里
                result = true;
            }
        }
		....
	}
当CViewxxxxxxxx的dispatchTouchEvent不调用super.dispatchTouchEvent时，

View的onTouchEvent当然不会被执行，

View的onTouchEvent不被执行，CViewxxxxxxxx.onTouchEvent形同虚设

## 情况C（针对View.dispatchTouchEvent【false】和View.onTouchEvent【super,false,true】）

由情况B得出的结论，当CViewxxxxxxxx的dispatchTouchEvent返回false时，CViewxxxxxxxx.onTouchEvent也是形同虚设，我们来看一下会发生什么







