# 蓝牙后台开关连接


## 前情概要

### 权限设置

	<uses-permission android:name="android.permission.BLUETOOTH" />
	<uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />
	<uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
	<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />



	https://github.com/NordicSemiconductor/Android-Scanner-Compat-Library
	implementation 'no.nordicsemi.android.support.v18:scanner:1.4.2'

	settings = new ScanSettings.Builder()
	        .setLegacy(false)
	        .setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY)
	        .setReportDelay(1000)
	        .setUseHardwareBatchingIfSupported(false)
	        .setUseHardwareFilteringIfSupported(false)
	        .build();
    mScanner.startScan(filters, settings, mScanCallback);

### 问题现象

	红米的手机，app在后台，关闭蓝牙，再等待1分钟，再打开蓝牙，oppo以及小米的手机无法连接。
	运行了app后，发现当app在后台扫描时，调用扫描后，接口没有回调。难道是我使用的方式不对吗？


### 实现方式
	
	开启一个前台服务，在里面注册监听蓝牙开关的广播，且在内部进行蓝牙扫描操作。


## 解决方法

### 框架问题

	首先考虑的是这个问题是哪个版本出现的，测试发现5.3.0的app还是支持的，那么5.3.0以后修改了什么？仔细看了下，是换了noric的扫描框架;

	仔细再去看了下NRF的文档

	setLegacy 默认为true，true表示使用的旧版本广播包协议，这个设置应该不会有问题，不管它了，
	
	setUseHardwareBatchingIfSupported 默认为true,表示如果他们支持硬件分流批处理的话，使用硬件分流批处理;false表示兼容机制;
	实际中发现设置为false时，才可以获取device name,设置为true时，无法获取device name;
	其实看了文档，还是不明白它是什么意思，大概明白就是使用false兼容性会强一点。
	
	setUseHardwareFilteringIfSupported 默认为true,表示硬件可以分流过滤，false表示兼容软件过滤也开启，使用更多的资源
	同理。这个也不是很明白它是什么意思，大概明白就是使用false会使用更多的资源。
	
	setScanMode 最重要的就是这个参数，根据文档提示，
	这个方法可以设置4个参数，
	
	SCAN_MODE_OPPORTUNISTIC 机会主义扫描，它会使用其他应用的扫描结果，这个一看就不敢用，万一没有其他的扫描结果，我的app岂不是坐那等死，肯定不能使用这个
	
	SCAN_MODE_LOW_POWER 低电量扫描，如果app不是在前台的话，会强制使用这个方式扫描
	
	SCAN_MODE_BALANCED  平衡扫描，会平衡电量以及扫描效率，算是折衷的方法
	
	SCAN_MODE_LOW_LATENCY 高效扫描，这种情况只允许app在前台时调用
	
	这么说的话， 我是不是只要判断app在后台的时候，判断使用SCAN_MODE_LOW_POWER的模式就可以了。我真是个小机灵鬼，然后实际测试发现，是不行的。实际情况是红米的手机无论是SCAN_MODE_LOW_POWER还是SCAN_MODE_LOW_LATENCY 都是没有回调的.
	
	为此我更换了另外一个扫描蓝牙库，发现扫描问题依然存在。

### 线程问题
	
	之后考虑是不是app在后台时，调用扫描的子线程被挂起了，但是线程里的log打印了啊，而后我又尝试了直接调用的扫描，不在线程中被调用，发现还是没有回调。
	
	与此同时，我又试了华为，三星，pix,oppo的手机，发现华为，三星，pix,在后台扫描时，是有回调的，也就是说小米家，跟oppo家的手机是有问题。
	
	而后，发现竞品的app是可以直接连接上设备的。进而开启了反编译之路，看看其他同行是怎么做的，反编译了2款app,一款使用了腾讯加固了根本看不到代码，另一款代码混淆了，虽然是混淆了，但是通过全局搜索关键的变量，系统的方法等，还是获取了一些有效的信息，实际发现它们并没有用SCAN_MODE_LOW_POWER的扫描方式，就是说此举是不通的。它是使用了系统的扫描方法，不同手机版本来使用Lescanner+ScannerCallback的兼容方式，难不成跟我的扫描库有关系？
	
	为此我更换了另外一个扫描蓝牙库，发现扫描问题依然存在。

### 构建最简单的demo

	至此，感觉解决问题的方向有点乱了，我决定重新构建一个单独的扫描demo,并使用系统的扫描方法。在不断的尝试中，发现另一个公司的朋友做的app也存在类似的问题，于是乎联系上他，看他是如何实现的，讨论发现其实大家实现的方式也差不多，他并没有给我带了太多的帮助。


### 联系朋友

	我突然想起来了还有另一个芯片原厂的Android朋友，于是乎联系上他，他提供了几个关键的点给我，
	1.编译版本(28,29)
	2.ACCESS_BACKGROUND_LOCATION，（没有加,编译版本是29的时间加出来的）
	3.前台服务（目前已经是了）
	4.pendIntent方式扫描（无效）
	5.直接连接不扫描（部分手机不可行）
	6.采用配对的方式（没有办法，我们设置不支持配对）
	7.Service添加android:foregroundServiceType="location"（没有加，实测connectdevice没有用）
 

### 解决问题

	实际测试后，发现ACCESS_BACKGROUND_LOCATION，这个可以解决oppo手机的扫描问题，但是小米的手机却依然还是存在扫描无结果，通过no filter的日志发现了一个重要的日志。当我发起连接时，
	D/LocationPolicy: [uid = 10257, op = 1] is blocked by location policy

	也就是说系统上做了后台的判定，扫描需要用到位置信息，而在后台时，app被限制用了位置信息，我把demo源码发给了他，他也用小米的重现了这个问题，正当不知道怎么开展的时候，对方给我一个好消息，通过红米手机的电池设置，当对app不进行限制电量使用且在service


## 总结方案

	华为+三星+pix:SCAN_MODE_LOW_LATENCY
	oppo:SCAN_MODE_LOW_LATENCY+ACCESS_BACKGROUND_LOCATION
	红米：SCAN_MODE_LOW_LATENCY+ACCESS_BACKGROUND_LOCATION+foregroundServiceType+不进行限制电量

	扫描要注意ACCESS_BACKGROUND_LOCATION+foregroundServiceType+电量限制
	noric的扫描框架没什么问题
	当扫描模式是 SCAN_MODE_LOW_LATENCY，filter加不加都会有回调
	当扫描模式是 SCAN_MODE_LOW_POWER，filter加不加都会有回调
