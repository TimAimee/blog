# 泛型和通配符

# 泛型
	
	定义在类中的泛型
	
	class Plate<T>{
		T t;
		
		private T getObj(){
			return t;
		}

		private void setObj(T t){
			this.t=t;
		}				
	}

	定义在方法中的泛型

	class Plate<T>{
		
		private <T>T getObj(){
			return t;
		}

		private <R> void setObj(T t,R r){
			this.t=t;
		}				
	}

# 通配符

	class Box<?>


## 上界通配符

	class Fruit {}
	class Apple extends Fruit {}
	class RedApple extends Apple {}
	
	<? extends T> 如果定义的是<Fruit>,那么<>可以是Fruit，Apple，RedApple

	<? extends T> 如果定义的是<Apple>,那么<>可以是Apple，RedApple

## 下界通配符
	
	class Fruit {}
	class Apple extends Fruit {}
	class RedApple extends Apple {}

	<? super T> 如果定义的是<Apple>,那么<>可以是 Apple，Fruit

	<? super T> 如果定义的是<Fruit>,那么<>只能是 Fruit


## Demo

	
	    /**
	     * 只能传apple,不能传Fruit
	     */
	    public void testGenic1() {
	        Log.i(str, "------泛型 testGenic1-------");
	        Apple apple = new Apple(10, 5);
	        GenicClass<Apple> genicClass = new GenicClass(apple);
	        Apple apple0 = genicClass.getT();
	        Log.i(str, apple0.toString());
	
	    }
	
		 GenicOprate: ------泛型 testGenic1-------
		 GenicOprate: Apple{radius=5, price=10}

--------------------------
	    /**
	     * 可以传apple,可以传Fruit
	     * 但是只能获取Fruit
	     */
	    public void testGenic2() {
	        Log.i(str, "-------泛型 testGenic2-------");
	        Apple apple = new Apple(10, 5);
	//        GenicClass<Fruit> genicClass = new GenicClass<Apple>(apple);//前面定义Fruit，后面不可以定义Apple
	        GenicClass<Fruit> genicClass = new GenicClass<Fruit>(apple);//可以传Fruit，可以传apple
	        Fruit fruit = genicClass.getT();//只能获取Fruit对象
	        Log.i(str, "fruit.getPrice()=" + fruit.getPrice());
	        Log.i(str, "fruit.toString()=" + fruit.toString());
	        Log.i(str, "fruit强制转apple");
	        Apple apple1 = (Apple) fruit;
	        Log.i(str, "apple1.getRadius()=" + apple1.getRadius());
	    }
	
		 GenicOprate: -------泛型 testGenic2-------
		 GenicOprate: fruit.getPrice()=10
		 GenicOprate: fruit.toString()=Apple{radius=5, price=10}
		 GenicOprate: fruit强制转apple
		 GenicOprate: apple1.getRadius()=5

--------------------------

	    /**
	     * 上界通配符 extends
	     */
	    public void testGenicBoundUp1() {
	        Log.i(str, "-------上界通配符 extends  testGenicBound1-------");
	        Fruit fruit = new Fruit(10);
	        GenicClass<? extends Fruit> genicClassFruit = new GenicClass<Fruit>(fruit);
	        Log.i(str, "genicClassFruit=" + genicClassFruit.toString());
	
	        //上界通配符 不能往里存，只能往外取
	        //genicClassFruit.setT(new Apple(12, 6));
	        Log.i(str, "genicClassFruit getT=" + genicClassFruit.getT().toString());
	
	        Apple apple = new Apple(10, 5);
	        GenicClass<? extends Fruit> genicClassApple = new GenicClass<Apple>(apple);//前面定义Fruit，后面可以定义Apple
	        Log.i(str, "genicClassApple=" + genicClassApple.toString());
	
	    }
	 
		 GenicOprate: -------上界通配符 extends  testGenicBound1-------
		 GenicOprate: genicClassFruit=GenicClass{t=Fruit{price=10}}
		 GenicOprate: genicClassFruit getT=Fruit{price=10}
		 GenicOprate: genicClassApple=GenicClass{t=Apple{radius=5, price=10}}

--------------------------
	
	    /**
	     * 上界通配符 extends
	     */
	    public void testGenicBoundUp2() {
	        Log.i(str, "-------上界通配符 extends testGenicBound2-------");
	        Fruit fruit = new Fruit(10);
	//        GenicClass<? extends Apple>  genicClassFruit=new GenicClass<>(fruit);//不可以传Fruit
	        Apple apple = new Apple(10, 5);
	        GenicClass<? extends Apple> genicClassApple = new GenicClass<>(apple);
	        Log.i(str, "genicClassApple=" + genicClassApple.toString());
	
	    }

	 GenicOprate: -------上界通配符 extends testGenicBound2-------
	 GenicOprate: genicClassApple=GenicClass{t=Apple{radius=5, price=10}}

--------------------------

	
	    /**
	     * 下界通配符 super
	     */
	    public void testGenicBoundDown1() {
	        Log.i(str, "-------下界通配符 super  testGenicBound1-------");
	        Fruit fruit = new Fruit(10);
	        GenicClass<? super Fruit> genicClassFruit = new GenicClass<Fruit>(fruit);
	        Log.i(str, "genicClassFruit=" + genicClassFruit.toString());
	        genicClassFruit.setT(new Fruit(8));
	        Log.i(str, "genicClassFruit setT(new Fruit(8))=" + genicClassFruit.toString());
	
	        Apple apple = new Apple(12, 50);
	        genicClassFruit.setT(apple);//不影响往里存，但往外取只能放在Object对象里
	        //读取出来的东西只能存放在Object类里。
	        Fruit t = (Fruit) genicClassFruit.getT();
	        Log.i(str, "genicClassFruit.setT(apple)=" + t.toString());
	
	//        GenicClass<? super Fruit>  genicClassApple=new GenicClass<Apple>(apple);//不可以传Apple
	    }
	
		 GenicOprate: -------下界通配符 super  testGenicBound1-------
		 GenicOprate: genicClassFruit=GenicClass{t=Fruit{price=10}}
		 GenicOprate: genicClassFruit setT(new Fruit(8))=GenicClass{t=Fruit{price=8}}
		 GenicOprate: genicClassFruit.setT(apple)=Apple{radius=50, price=12}

--------------------------

	    /**
	     * 下界通配符 super
	     */
	    public void testGenicBoundDown2() {
	        Log.i(str, "-------下界通配符 super  testGenicBound2-------");
	        Fruit fruit = new Fruit(10);
	        GenicClass<? super Apple> genicClassFruit = new GenicClass<Fruit>(fruit);//可以传Fruit
	        Log.i(str, "genicClassFruit=" + genicClassFruit.toString());
	
	        Apple apple = new Apple(10, 5);
	        GenicClass<? super Apple> genicClassApple = new GenicClass<Apple>(apple);//可以传Apple
	        Log.i(str, "genicClassApple=" + genicClassApple.toString());
	    }
	
		 GenicOprate: -------下界通配符 super  testGenicBound2-------
		 GenicOprate: genicClassFruit=GenicClass{t=Fruit{price=10}}
		 GenicOprate: genicClassApple=GenicClass{t=Apple{radius=5, price=10}}


--------------------------

# PESC原则(Producer Extends Consumer Super)

	频繁往外读取内容的适合用上界 Extends
	经常往里插入的，适合用下界Super

	https://www.zhihu.com/question/20400700

